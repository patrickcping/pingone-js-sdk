/**
 * PingOne Platform API - SSO and Base
 * The PingOne Platform API covering the base and SSO services (otherwise known as the Management APIs)
 *
 * The version of the OpenAPI document: 2023-06-29
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import LinksHATEOAS from './LinksHATEOAS';
import ObjectEnvironment from './ObjectEnvironment';
import PasswordPolicyHistory from './PasswordPolicyHistory';
import PasswordPolicyLength from './PasswordPolicyLength';
import PasswordPolicyLockout from './PasswordPolicyLockout';
import PasswordPolicyMinCharacters from './PasswordPolicyMinCharacters';

/**
 * The PasswordPolicy model module.
 * @module model/PasswordPolicy
 * @version 2023-06-29
 */
class PasswordPolicy {
    /**
     * Constructs a new <code>PasswordPolicy</code>.
     * @alias module:model/PasswordPolicy
     * @param excludesCommonlyUsed {Boolean} Set this to true to ensure the password is not one of the commonly used passwords.
     * @param excludesProfileData {Boolean} Set this to true to ensure the password is not an exact match for the value of any attribute in the user’s profile, such as name, phone number, or address.
     * @param name {String} The name of the password policy. This value must be unique within the environment.
     * @param notSimilarToCurrent {Boolean} Set this to true to ensure that the proposed password is not too similar to the user's current password based on the Levenshtein distance algorithm. The value of this parameter is evaluated only for password change actions in which the user enters both the current and the new password. By design, PingOne does not know the user's current password.
     */
    constructor(excludesCommonlyUsed, excludesProfileData, name, notSimilarToCurrent) { 
        
        PasswordPolicy.initialize(this, excludesCommonlyUsed, excludesProfileData, name, notSimilarToCurrent);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, excludesCommonlyUsed, excludesProfileData, name, notSimilarToCurrent) { 
        obj['excludesCommonlyUsed'] = excludesCommonlyUsed;
        obj['excludesProfileData'] = excludesProfileData;
        obj['name'] = name;
        obj['notSimilarToCurrent'] = notSimilarToCurrent;
    }

    /**
     * Constructs a <code>PasswordPolicy</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/PasswordPolicy} obj Optional instance to populate.
     * @return {module:model/PasswordPolicy} The populated <code>PasswordPolicy</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new PasswordPolicy();

            if (data.hasOwnProperty('_links')) {
                obj['_links'] = LinksHATEOAS.constructFromObject(data['_links']);
            }
            if (data.hasOwnProperty('bypassPolicy')) {
                obj['bypassPolicy'] = ApiClient.convertToType(data['bypassPolicy'], 'Boolean');
            }
            if (data.hasOwnProperty('createdAt')) {
                obj['createdAt'] = ApiClient.convertToType(data['createdAt'], 'String');
            }
            if (data.hasOwnProperty('currentPassword')) {
                obj['currentPassword'] = ApiClient.convertToType(data['currentPassword'], 'String');
            }
            if (data.hasOwnProperty('default')) {
                obj['default'] = ApiClient.convertToType(data['default'], 'Boolean');
            }
            if (data.hasOwnProperty('description')) {
                obj['description'] = ApiClient.convertToType(data['description'], 'String');
            }
            if (data.hasOwnProperty('environment')) {
                obj['environment'] = ObjectEnvironment.constructFromObject(data['environment']);
            }
            if (data.hasOwnProperty('excludesCommonlyUsed')) {
                obj['excludesCommonlyUsed'] = ApiClient.convertToType(data['excludesCommonlyUsed'], 'Boolean');
            }
            if (data.hasOwnProperty('excludesProfileData')) {
                obj['excludesProfileData'] = ApiClient.convertToType(data['excludesProfileData'], 'Boolean');
            }
            if (data.hasOwnProperty('history')) {
                obj['history'] = PasswordPolicyHistory.constructFromObject(data['history']);
            }
            if (data.hasOwnProperty('id')) {
                obj['id'] = ApiClient.convertToType(data['id'], 'String');
            }
            if (data.hasOwnProperty('length')) {
                obj['length'] = PasswordPolicyLength.constructFromObject(data['length']);
            }
            if (data.hasOwnProperty('lockout')) {
                obj['lockout'] = PasswordPolicyLockout.constructFromObject(data['lockout']);
            }
            if (data.hasOwnProperty('maxAgeDays')) {
                obj['maxAgeDays'] = ApiClient.convertToType(data['maxAgeDays'], 'Number');
            }
            if (data.hasOwnProperty('maxRepeatedCharacters')) {
                obj['maxRepeatedCharacters'] = ApiClient.convertToType(data['maxRepeatedCharacters'], 'Number');
            }
            if (data.hasOwnProperty('minAgeDays')) {
                obj['minAgeDays'] = ApiClient.convertToType(data['minAgeDays'], 'Number');
            }
            if (data.hasOwnProperty('minCharacters')) {
                obj['minCharacters'] = PasswordPolicyMinCharacters.constructFromObject(data['minCharacters']);
            }
            if (data.hasOwnProperty('minComplexity')) {
                obj['minComplexity'] = ApiClient.convertToType(data['minComplexity'], 'Number');
            }
            if (data.hasOwnProperty('minUniqueCharacters')) {
                obj['minUniqueCharacters'] = ApiClient.convertToType(data['minUniqueCharacters'], 'Number');
            }
            if (data.hasOwnProperty('name')) {
                obj['name'] = ApiClient.convertToType(data['name'], 'String');
            }
            if (data.hasOwnProperty('newPassword')) {
                obj['newPassword'] = ApiClient.convertToType(data['newPassword'], 'String');
            }
            if (data.hasOwnProperty('notSimilarToCurrent')) {
                obj['notSimilarToCurrent'] = ApiClient.convertToType(data['notSimilarToCurrent'], 'Boolean');
            }
            if (data.hasOwnProperty('populationCount')) {
                obj['populationCount'] = ApiClient.convertToType(data['populationCount'], 'Number');
            }
            if (data.hasOwnProperty('updatedAt')) {
                obj['updatedAt'] = ApiClient.convertToType(data['updatedAt'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>PasswordPolicy</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>PasswordPolicy</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of PasswordPolicy.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['createdAt'] && !(typeof data['createdAt'] === 'string' || data['createdAt'] instanceof String)) {
            throw new Error("Expected the field `createdAt` to be a primitive type in the JSON string but got " + data['createdAt']);
        }
        // ensure the json data is a string
        if (data['currentPassword'] && !(typeof data['currentPassword'] === 'string' || data['currentPassword'] instanceof String)) {
            throw new Error("Expected the field `currentPassword` to be a primitive type in the JSON string but got " + data['currentPassword']);
        }
        // ensure the json data is a string
        if (data['description'] && !(typeof data['description'] === 'string' || data['description'] instanceof String)) {
            throw new Error("Expected the field `description` to be a primitive type in the JSON string but got " + data['description']);
        }
        // validate the optional field `environment`
        if (data['environment']) { // data not null
          ObjectEnvironment.validateJSON(data['environment']);
        }
        // validate the optional field `history`
        if (data['history']) { // data not null
          PasswordPolicyHistory.validateJSON(data['history']);
        }
        // ensure the json data is a string
        if (data['id'] && !(typeof data['id'] === 'string' || data['id'] instanceof String)) {
            throw new Error("Expected the field `id` to be a primitive type in the JSON string but got " + data['id']);
        }
        // validate the optional field `length`
        if (data['length']) { // data not null
          PasswordPolicyLength.validateJSON(data['length']);
        }
        // validate the optional field `lockout`
        if (data['lockout']) { // data not null
          PasswordPolicyLockout.validateJSON(data['lockout']);
        }
        // validate the optional field `minCharacters`
        if (data['minCharacters']) { // data not null
          PasswordPolicyMinCharacters.validateJSON(data['minCharacters']);
        }
        // ensure the json data is a string
        if (data['name'] && !(typeof data['name'] === 'string' || data['name'] instanceof String)) {
            throw new Error("Expected the field `name` to be a primitive type in the JSON string but got " + data['name']);
        }
        // ensure the json data is a string
        if (data['newPassword'] && !(typeof data['newPassword'] === 'string' || data['newPassword'] instanceof String)) {
            throw new Error("Expected the field `newPassword` to be a primitive type in the JSON string but got " + data['newPassword']);
        }
        // ensure the json data is a string
        if (data['updatedAt'] && !(typeof data['updatedAt'] === 'string' || data['updatedAt'] instanceof String)) {
            throw new Error("Expected the field `updatedAt` to be a primitive type in the JSON string but got " + data['updatedAt']);
        }

        return true;
    }


}

PasswordPolicy.RequiredProperties = ["excludesCommonlyUsed", "excludesProfileData", "name", "notSimilarToCurrent"];

/**
 * @member {module:model/LinksHATEOAS} _links
 */
PasswordPolicy.prototype['_links'] = undefined;

/**
 * Determines whether the password policy for a user will be ignored. If this property is omitted from a CREATE Password Policy request, its value is set to false.
 * @member {Boolean} bypassPolicy
 * @default false
 */
PasswordPolicy.prototype['bypassPolicy'] = false;

/**
 * The date and time the resource was created (format ISO-8061).
 * @member {String} createdAt
 */
PasswordPolicy.prototype['createdAt'] = undefined;

/**
 * The current password to be verified before the new password is set. Required for self-change when the user already has a password (the user whose password is being changed is the same as the actor in the access token).
 * @member {String} currentPassword
 */
PasswordPolicy.prototype['currentPassword'] = undefined;

/**
 * Indicates whether this password policy is enforced within the environment. When set to true, all other password policies are set to false.
 * @member {Boolean} default
 */
PasswordPolicy.prototype['default'] = undefined;

/**
 * Specifies the brief description of the password policy.
 * @member {String} description
 */
PasswordPolicy.prototype['description'] = undefined;

/**
 * @member {module:model/ObjectEnvironment} environment
 */
PasswordPolicy.prototype['environment'] = undefined;

/**
 * Set this to true to ensure the password is not one of the commonly used passwords.
 * @member {Boolean} excludesCommonlyUsed
 */
PasswordPolicy.prototype['excludesCommonlyUsed'] = undefined;

/**
 * Set this to true to ensure the password is not an exact match for the value of any attribute in the user’s profile, such as name, phone number, or address.
 * @member {Boolean} excludesProfileData
 */
PasswordPolicy.prototype['excludesProfileData'] = undefined;

/**
 * @member {module:model/PasswordPolicyHistory} history
 */
PasswordPolicy.prototype['history'] = undefined;

/**
 * The password resource’s unique identifier.
 * @member {String} id
 */
PasswordPolicy.prototype['id'] = undefined;

/**
 * @member {module:model/PasswordPolicyLength} length
 */
PasswordPolicy.prototype['length'] = undefined;

/**
 * @member {module:model/PasswordPolicyLockout} lockout
 */
PasswordPolicy.prototype['lockout'] = undefined;

/**
 * The maximum number of days the same password can be used before it must be changed. The value must be a positive, non-zero integer.  The value must be greater than the sum of minAgeDays (if set) + 21 (the expiration warning interval for passwords).
 * @member {Number} maxAgeDays
 */
PasswordPolicy.prototype['maxAgeDays'] = undefined;

/**
 * The maximum number of repeated characters allowed. This property is not enforced when not present.
 * @member {Number} maxRepeatedCharacters
 */
PasswordPolicy.prototype['maxRepeatedCharacters'] = undefined;

/**
 * The minimum number of days a password must be used before changing. The value must be a positive, non-zero integer. This property is not enforced when not present.
 * @member {Number} minAgeDays
 */
PasswordPolicy.prototype['minAgeDays'] = undefined;

/**
 * @member {module:model/PasswordPolicyMinCharacters} minCharacters
 */
PasswordPolicy.prototype['minCharacters'] = undefined;

/**
 * The minimum complexity of the password based on the concept of password haystacks. The value is the number of days required to exhaust the entire search space during a brute force attack. This property is not enforced when not present.
 * @member {Number} minComplexity
 */
PasswordPolicy.prototype['minComplexity'] = undefined;

/**
 * The minimum number of unique characters required. This property is not enforced when not present.
 * @member {Number} minUniqueCharacters
 */
PasswordPolicy.prototype['minUniqueCharacters'] = undefined;

/**
 * The name of the password policy. This value must be unique within the environment.
 * @member {String} name
 */
PasswordPolicy.prototype['name'] = undefined;

/**
 * The new password (must satisfy all requirements).
 * @member {String} newPassword
 */
PasswordPolicy.prototype['newPassword'] = undefined;

/**
 * Set this to true to ensure that the proposed password is not too similar to the user's current password based on the Levenshtein distance algorithm. The value of this parameter is evaluated only for password change actions in which the user enters both the current and the new password. By design, PingOne does not know the user's current password.
 * @member {Boolean} notSimilarToCurrent
 */
PasswordPolicy.prototype['notSimilarToCurrent'] = undefined;

/**
 * Returned in the response. The number of populations associated with the password policy.
 * @member {Number} populationCount
 */
PasswordPolicy.prototype['populationCount'] = undefined;

/**
 * The date and time the resource was last updated (format ISO-8061).
 * @member {String} updatedAt
 */
PasswordPolicy.prototype['updatedAt'] = undefined;






export default PasswordPolicy;

